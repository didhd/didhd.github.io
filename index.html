<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>í…ì‚¬ìŠ¤ í™€ë¤ ì‹±ê¸€ í”Œë ˆì´ ì—°ìŠµ</title>
    <link rel="stylesheet" href="holdem3.css">
</head>

<body>
    <div class="container">
        <h1>í™€ë¤ ì‹±ê¸€ í”Œë ˆì´ ì—°ìŠµ</h1>
        <div class="top-panel">
            <button onclick="resetChips()" class="reset-button tooltip">ì¹© ë¦¬ì…‹
                <span class="tooltiptext">ë‚´ ì¹©ê³¼ ìƒëŒ€ ì¹©ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.</span>
            </button>
            <button onclick="toggleHelp()" class="help-button tooltip">ë„ì›€ë§
                <span class="tooltiptext">í…ì‚¬ìŠ¤ í™€ë¤ ê·œì¹™ê³¼ ë‹¨ê³„ë³„ ì„¤ëª… ë³´ê¸°</span>
            </button>
        </div>
        <div class="game-area">
            <div class="stage-indicator" id="stage-indicator">
                í”„ë¦¬í”Œë
                <div class="stage-tooltip" id="stage-tooltip">
                    <strong>í˜„ì¬ ë¼ìš´ë“œ: í”„ë¦¬í”Œë</strong><br>
                    í™€ì¹´ë“œ(ë‚´ ì¹´ë“œ 2ì¥) ë°›ì€ í›„ ì²« ë² íŒ… ë‹¨ê³„.<br>
                    ëª¨ë‘ ì½œ/ì²´í¬í•˜ë©´ í”Œë ë‹¨ê³„ë¡œ ì§„í–‰.
                </div>
            </div>
            <div class="genie-advice" id="genie">
                <h3>ì§€ë‹ˆì˜ ì¡°ì–¸</h3>
                <div id="genie-message">ê²Œì„ ì‹œì‘! í˜„ì¬ ìƒí™©ì— ë”°ë¥¸ ì „ëµì„ ì œì•ˆí•©ë‹ˆë‹¤.</div>
            </div>

            <div class="info-panel">
                <div class="chips-info">
                    ìƒëŒ€ ì¹©: <span id="opponent-stack">1000</span> <span class="tooltip">ğŸ’°<span class="tooltiptext">ìƒëŒ€ ë³´ìœ 
                            ì¹©</span></span>
                </div>
                <div class="chips-info">
                    ë‚´ ì¹©: <span id="player-stack">1000</span> <span class="tooltip">ğŸ’°<span class="tooltiptext">ë‚´ ë³´ìœ 
                            ì¹©</span></span>
                </div>
                <div class="betting-info tooltip">
                    <strong>ê¸°ë³¸ ì •ë³´</strong><br>
                    SB: 5ì¹©, BB: 10ì¹©<br>
                    ê¸°ë³¸ ë² íŒ… ë‹¨ìœ„: 10ì¹©(ì˜ˆì‹œ)<br>
                    <span id="pot-amount">íŒŸ: 0</span>
                    <span class="tooltiptext">í˜„ì¬ê¹Œì§€ ëª¨ì¸ íŒŸ ê¸ˆì•¡</span>
                </div>
            </div>

            <div class="opponent-area">
                <h2>ìƒëŒ€(ë”œëŸ¬)</h2>
                <div class="opponent-cards" id="opponent-cards"></div>
            </div>
            <div class="community-cards" id="community-cards"></div>
            <div class="player-area">
                <h2>í”Œë ˆì´ì–´(<span id="blind-info">?</span>)</h2>
                <div class="player-cards" id="player-cards"></div>
                <!-- í”Œë ˆì´ì–´ ìµœê°• ì¡±ë³´ í‘œì‹œ -->
                <div class="player-hand-rank" id="player-hand-rank"
                    style="font-size:0.9em; margin-bottom:10px; font-weight:bold; color:#2c3e50;">
                    í˜„ì¬ ìµœê°• ì¡±ë³´: -
                </div>

                <div class="action-buttons">
                    <button onclick="playerCheck()" class="tooltip">ì²´í¬<div class="tooltiptext">ì¶”ê°€ ë² íŒ… ì—†ì´ í„´ì„ ë„˜ê¹€</div>
                    </button>
                    <button onclick="playerBet()" class="tooltip">ë² íŒ…<div class="tooltiptext">ë² íŒ… ì‹œì‘</div></button>
                    <button onclick="playerCall()" class="tooltip">ì½œ<div class="tooltiptext">ìƒëŒ€ ë² íŒ… ë”°ë¼ê°€ê¸°</div></button>
                    <button onclick="playerRaise()" class="tooltip">ë ˆì´ì¦ˆ<div class="tooltiptext">ìƒëŒ€ë³´ë‹¤ ë†’ê²Œ ë² íŒ…</div>
                    </button>
                    <button onclick="playerFold()" class="tooltip">í´ë“œ<div class="tooltiptext">íŒ¨ í¬ê¸°</div></button>
                </div>
                <div class="message-area" id="message-area"></div>
                <button id="next-game-button" style="display:none;" onclick="nextGame()"
                    class="next-game-button tooltip">
                    ë‹¤ìŒ ê²Œì„
                    <span class="tooltiptext">ìƒˆ í•¸ë“œ ì‹œì‘</span>
                </button>
            </div>
        </div>
    </div>

    <!-- ë„ì›€ë§ ì˜¤ë²„ë ˆì´ -->
    <div id="help-overlay" class="help-overlay" style="display:none;">
        <div class="help-content">
            <h2>ë„ì›€ë§ - í…ì‚¬ìŠ¤ í™€ë¤ ê¸°ë³¸ ê°œë…</h2>
            <button class="help-close-button" onclick="toggleHelp()">X</button>
            <div class="help-text-area">
                <p><strong>í™€ë¤ì€ ì„¸ ë²ˆì— ê±¸ì³ì„œ ê°€ìš´ë°ì— ê³µìš© ì¹´ë“œë¥¼ ê¹ë‹¤:</strong><br>
                    í”Œë(3ì¥), í„´(1ì¥ ì¶”ê°€), ë¦¬ë²„(1ì¥ ì¶”ê°€) ìˆœì„œëŒ€ë¡œ ì˜¤í”ˆë˜ë©°,<br>
                    ê° ë‹¨ê³„ ì „í›„ë¡œ ë² íŒ… ë¼ìš´ë“œê°€ ì´ 4ë²ˆ ì§„í–‰ëœë‹¤.</p>
                <p><strong>í”„ë¦¬ í”Œë(Pre-flop):</strong><br>
                    í”Œë ˆì´ì–´ë“¤ì´ 2ì¥ì”© í™€ì¹´ë“œë¥¼ ë°›ì€ ìƒíƒœ. SB, BBê°€ ê¸°ë³¸ íŒëˆì„ ë‚¸ ë’¤ ì•¡ì…˜ ì‹œì‘. ëª¨ë‘ ì½œ/ì²´í¬ ì‹œ í”Œëìœ¼ë¡œ ì§„í–‰.</p>
                <p>í”Œë(Flop): ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ 3ì¥ ì˜¤í”ˆ í›„ ë² íŒ…</p>
                <p>í„´(Turn): ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ 4ì¥ì§¸ ì˜¤í”ˆ í›„ ë² íŒ…</p>
                <p>ë¦¬ë²„(River): ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ 5ì¥ì§¸ ì˜¤í”ˆ í›„ ë§ˆì§€ë§‰ ë² íŒ…</p>
                <p>ì‡¼ë‹¤ìš´: ë‚¨ì€ í”Œë ˆì´ì–´ë“¤ì´ íŒ¨ë¥¼ ê³µê°œí•´ ìŠ¹ì ê²°ì •. ê°€ì¥ ë†’ì€ ì¡±ë³´ë¥¼ ê°€ì§„ í”Œë ˆì´ì–´ê°€ íŒŸ íšë“.</p>

                <p>SB/BB: ë¼ìš´ë“œ ì‹œì‘ ì „ ë‚´ì•¼ í•˜ëŠ” ê°•ì œ ë² íŒ…. SBëŠ” ì ˆë°˜, BBëŠ” ì „ì²´ ë¸”ë¼ì¸ë“œ.</p>
                <p>í¬ì»¤ëŠ” ìš´+ì „ëµ. ì¥ê¸°ì  ìˆ˜ìµì„ ëª©í‘œë¡œ í™•ë¥ , ìƒëŒ€ íŒ¨í„´, ì‹¬ë¦¬ì „ í™œìš©.</p>
                <p>ì§€ë‹ˆ ì¡°ì–¸ ì°¸ê³ : ë¶ˆë¦¬í•˜ë©´ í´ë“œë¡œ ì†ì‹¤ ìµœì†Œí™”, ìœ ë¦¬í•˜ë©´ ë² íŒ…/ë ˆì´ì¦ˆë¡œ ìˆ˜ìµ ê·¹ëŒ€í™”.</p>
            </div>
        </div>
    </div>

    <script>
        let deck = [];
        const suits = ["C", "D", "H", "S"];
        const values = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"];

        let playerStack;
        let opponentStack;
        let pot = 0;
        let playerCards = [];
        let opponentCards = [];
        let communityCards = [];
        let gameStage = 'preflop';
        let gameOver = false;

        let currentBet = 0;
        let playerContribution = 0;
        let opponentContribution = 0;

        let smallBlind = 5;
        let bigBlind = 10;
        let playerIsSB;

        function toggleHelp() {
            const overlay = document.getElementById('help-overlay');
            if (overlay.style.display === 'none' || overlay.style.display === '') {
                overlay.style.display = 'block';
            } else {
                overlay.style.display = 'none';
            }
        }

        function loadFromStorage() {
            let storedPStack = localStorage.getItem('playerStack');
            let storedOStack = localStorage.getItem('opponentStack');
            let storedSB = localStorage.getItem('playerIsSB');
            if (storedPStack && storedOStack && storedSB) {
                playerStack = parseInt(storedPStack);
                opponentStack = parseInt(storedOStack);
                playerIsSB = (storedSB === 'true');
            } else {
                playerStack = 1000;
                opponentStack = 1000;
                playerIsSB = Math.random() < 0.5;
            }
        }

        function saveToStorage() {
            localStorage.setItem('playerStack', playerStack.toString());
            localStorage.setItem('opponentStack', opponentStack.toString());
            localStorage.setItem('playerIsSB', playerIsSB.toString());
        }

        function resetChips() {
            localStorage.removeItem('playerStack');
            localStorage.removeItem('opponentStack');
            localStorage.removeItem('playerIsSB');
            playerStack = 1000;
            opponentStack = 1000;
            playerIsSB = Math.random() < 0.5;
            startGame();
        }

        function createDeck() {
            deck = [];
            for (let s of suits) {
                for (let v of values) {
                    deck.push(v + s);
                }
            }
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function startGame() {
            loadFromStorage();
            gameOver = false;
            communityCards = [];
            currentBet = 0;
            playerContribution = 0;
            opponentContribution = 0;
            gameStage = 'preflop';

            let sbPlayer, bbPlayer;
            if (playerIsSB) {
                sbPlayer = "player";
                bbPlayer = "opponent";
            } else {
                sbPlayer = "opponent";
                bbPlayer = "player";
            }

            if (sbPlayer === "player") {
                playerStack -= smallBlind;
                opponentStack -= bigBlind;
            } else {
                opponentStack -= smallBlind;
                playerStack -= bigBlind;
            }
            pot = smallBlind + bigBlind;
            currentBet = bigBlind;

            createDeck();
            shuffleDeck();
            dealHoleCards();
            enableAllButtons();
            document.getElementById('next-game-button').style.display = 'none';
            updateAllDisplays();
            setMessage(`ìƒˆ ê²Œì„ ì‹œì‘! SB:${smallBlind}, BB:${bigBlind}`);
            updateGenieMessage();
            updateBlindInfo();
        }

        function nextGame() {
            playerIsSB = !playerIsSB;
            saveToStorage();
            startGame();
        }

        function updateBlindInfo() {
            const bi = document.getElementById('blind-info');
            if (!bi) return;
            bi.textContent = playerIsSB ? 'SB' : 'BB';
        }

        function dealHoleCards() {
            playerCards = [deck.pop(), deck.pop()];
            opponentCards = [deck.pop(), deck.pop()];
        }

        function updateAllDisplays() {
            updateStageIndicator();
            updatePlayerCardsDisplay();
            updateOpponentCardsDisplay();
            updateCommunityCardsDisplay();
            updatePotDisplay();
            updateStacksDisplay();
            updateGenieMessage();
            updateActionButtons();
            displayPlayerBestRank();
        }

        function displayPlayerBestRank() {
            const playerHandRankElem = document.getElementById('player-hand-rank');
            if (!playerHandRankElem) return;
            const fullPlayerHand = playerCards.concat(communityCards);
            if (fullPlayerHand.length < 5) {
                playerHandRankElem.textContent = "í˜„ì¬ ìµœê°• ì¡±ë³´: ì¹´ë“œ ë¶€ì¡±";
                return;
            }
            const res = evaluateHand(fullPlayerHand);
            const rankName = getRankName(res.rank);
            playerHandRankElem.textContent = `í˜„ì¬ ìµœê°• ì¡±ë³´: ${rankName || '-'}`;
        }

        function updateActionButtons() {
            const buttons = {
                check: document.querySelector('.action-buttons button:nth-child(1)'),
                bet: document.querySelector('.action-buttons button:nth-child(2)'),
                call: document.querySelector('.action-buttons button:nth-child(3)'),
                raise: document.querySelector('.action-buttons button:nth-child(4)'),
                fold: document.querySelector('.action-buttons button:nth-child(5)')
            };
            if (!buttons.check) return;

            if (gameOver) {
                for (let b in buttons) buttons[b].disabled = true;
                return;
            }

            let callAmount = currentBet - playerContribution;
            for (let b in buttons) buttons[b].disabled = true;

            if (callAmount > 0) {
                // ì½œ ìƒí™©
                if (playerStack >= callAmount) buttons.call.disabled = false;
                if (playerStack > callAmount) buttons.raise.disabled = false;
                buttons.fold.disabled = false;
            } else {
                // ì¶”ê°€ ë² íŒ… ì—†ìŒ
                buttons.check.disabled = false;
                if (playerStack > 0) buttons.bet.disabled = false;
                if (playerStack > 0) buttons.raise.disabled = false;
                buttons.fold.disabled = false;
            }
        }

        function updateStacksDisplay() {
            document.getElementById('player-stack').textContent = playerStack;
            document.getElementById('opponent-stack').textContent = opponentStack;
        }

        function cardToDisplay(card) {
            const rankMap = { 'T': '10', 'J': 'J', 'Q': 'Q', 'K': 'K', 'A': 'A' };
            let rank = card[0];
            if (rankMap[rank]) rank = rankMap[rank];
            let suit = card[1];
            let suitChar, colorClass;
            switch (suit) {
                case 'C': suitChar = 'â™£'; colorClass = 'black'; break;
                case 'D': suitChar = 'â™¦'; colorClass = 'red'; break;
                case 'H': suitChar = 'â™¥'; colorClass = 'red'; break;
                case 'S': suitChar = 'â™ '; colorClass = 'black'; break;
            }
            return { text: rank + suitChar, color: colorClass };
        }

        function updatePlayerCardsDisplay() {
            const pc = document.getElementById('player-cards');
            if (!pc) return;
            pc.innerHTML = '';
            playerCards.forEach(card => {
                const { text, color } = cardToDisplay(card);
                let cardDiv = document.createElement('div');
                cardDiv.classList.add('card', color);
                cardDiv.textContent = text;
                pc.appendChild(cardDiv);
            });
        }

        function updateOpponentCardsDisplay(showDown = false) {
            const oc = document.getElementById('opponent-cards');
            if (!oc) return;
            oc.innerHTML = '';
            if (gameOver || showDown || gameStage === 'showdown') {
                opponentCards.forEach(card => {
                    const { text, color } = cardToDisplay(card);
                    const cardDiv = document.createElement('div');
                    cardDiv.classList.add('card', color);
                    cardDiv.textContent = text;
                    oc.appendChild(cardDiv);
                });
            } else {
                oc.innerHTML = `<div class="card back"></div><div class="card back"></div>`;
            }
        }

        function updateCommunityCardsDisplay() {
            const cc = document.getElementById('community-cards');
            if (!cc) return;
            cc.innerHTML = '';
            communityCards.forEach(card => {
                const { text, color } = cardToDisplay(card);
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card', color);
                cardDiv.textContent = text;
                cc.appendChild(cardDiv);
            });
            while (cc.childElementCount < 5) {
                const emptyCard = document.createElement('div');
                emptyCard.classList.add('card', 'back');
                emptyCard.textContent = '';
                cc.appendChild(emptyCard);
            }
        }

        function updatePotDisplay() {
            const potElem = document.getElementById('pot-amount');
            if (!potElem) return;
            potElem.textContent = `íŒŸ: ${pot}`;
        }

        function updateStageIndicator() {
            const si = document.getElementById('stage-indicator');
            const stt = document.getElementById('stage-tooltip');
            if (!si || !stt) return;

            let desc = '';
            let roundName = '';
            switch (gameStage) {
                case 'preflop':
                    roundName = 'í”„ë¦¬í”Œë'; desc = 'í™€ì¹´ë“œ 2ì¥ í›„ ì²« ë² íŒ… ë‹¨ê³„.';
                    break;
                case 'flop':
                    roundName = 'í”Œë'; desc = 'ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ 3ì¥ ê³µê°œ í›„ ë² íŒ….';
                    break;
                case 'turn':
                    roundName = 'í„´'; desc = '4ë²ˆì§¸ ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ ê³µê°œ í›„ ë² íŒ….';
                    break;
                case 'river':
                    roundName = 'ë¦¬ë²„'; desc = '5ë²ˆì§¸ ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ ê³µê°œ í›„ ë² íŒ….';
                    break;
                case 'showdown':
                    roundName = 'ì‡¼ë‹¤ìš´'; desc = 'ë² íŒ… ì¢…ë£Œ í›„ íŒ¨ ê³µê°œ, ìŠ¹ì ê²°ì •.';
                    break;
                default:
                    roundName = ''; desc = '';
            }
            si.textContent = roundName;
            stt.innerHTML = `<strong>í˜„ì¬ ë¼ìš´ë“œ: ${roundName}</strong><br>${desc}`;
        }

        function setMessage(msg) {
            const msgArea = document.getElementById('message-area');
            if (!msgArea) return;
            msgArea.textContent = msg;
        }

        function updateGenieMessage() {
            const genie = document.getElementById('genie-message');
            if (!genie) return;
            if (gameOver) {
                genie.textContent = 'ì‡¼ë‹¤ìš´ ì™„ë£Œ! [ë‹¤ìŒ ê²Œì„] ë²„íŠ¼ìœ¼ë¡œ ìƒˆ í•¸ë“œ ì‹œì‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.';
                return;
            }

            let playerEV = monteCarloEV(playerCards, opponentCards, communityCards, gameStage);

            let advice = '';
            if (playerEV > 0.7) {
                advice = "ë‹¹ì‹ ì˜ íŒ¨ëŠ” ë§¤ìš° ê°•ë ¥! ê³¼ê°í•œ ë² íŒ…ì´ë‚˜ ë ˆì´ì¦ˆë¡œ ìƒëŒ€ë¥¼ ì••ë°•í•˜ì„¸ìš”.";
            } else if (playerEV > 0.5) {
                advice = "ê½¤ ìœ ë¦¬í•œ ìƒí™©. ê³µê²©ì  í”Œë ˆì´ë¡œ ìˆ˜ìµ ê·¹ëŒ€í™”ë¥¼ ë…¸ë ¤ë³´ì„¸ìš”.";
            } else if (playerEV > 0.3) {
                advice = "ìš°ìœ„ë¥¼ í™•ì‹ í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. ì‹ ì¤‘íˆ í–‰ë™í•˜ê³  ìƒëŒ€ì˜ ì•¡ì…˜ì„ ì£¼ì‹œí•˜ì„¸ìš”.";
            } else {
                advice = "ìƒëŒ€ê°€ ìœ ë¦¬í•´ ë³´ì…ë‹ˆë‹¤. ë¬´ë¦¬í•œ í”Œë ˆì´ë³´ë‹¤ í´ë“œë¡œ ì†ì‹¤ ìµœì†Œí™”ë¥¼ ê³ ë ¤í•˜ì„¸ìš”.";
            }
            genie.textContent = advice;
        }

        function disableAllButtons() {
            const buttons = document.querySelectorAll('.action-buttons button');
            buttons.forEach(b => b.disabled = true);
        }
        function enableAllButtons() {
            const buttons = document.querySelectorAll('.action-buttons button');
            buttons.forEach(b => b.disabled = false);
        }

        function playerFold() {
            if (gameOver) return;
            setMessage('í´ë“œ! ìƒëŒ€ê°€ íŒŸì„ ê°€ì ¸ê°‘ë‹ˆë‹¤.');
            opponentStack += pot;
            endHand();
        }

        function playerCheck() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (callAmount > 0) {
                setMessage('ì²´í¬ ë¶ˆê°€! ì½œ ë˜ëŠ” í´ë“œí•´ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }
            setMessage('ì²´í¬');
            updateAllDisplays();
            opponentAction('check');
        }

        function playerBet() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (callAmount > 0) {
                setMessage('ì½œ/í´ë“œ/ë ˆì´ì¦ˆ í•´ì•¼í•©ë‹ˆë‹¤. ë² íŒ… ë¶ˆê°€.');
                return;
            }
            let betSize = 20;
            if (playerStack < betSize) betSize = playerStack;
            playerStack -= betSize;
            playerContribution += betSize;
            pot += betSize;
            currentBet = playerContribution;
            setMessage(`ë² íŒ… ${betSize}ì¹©`);
            updateAllDisplays();
            opponentAction('bet', betSize);
        }

        function playerCall() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (callAmount <= 0) {
                setMessage('ì½œí•  ë² íŒ…ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            if (playerStack < callAmount) callAmount = playerStack;
            playerStack -= callAmount;
            playerContribution += callAmount;
            pot += callAmount;
            setMessage(`ì½œ ${callAmount}ì¹©`);
            updateAllDisplays();
            checkRoundEndOrOpponentAction('call');
        }

        function playerRaise() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (playerStack <= callAmount) {
                setMessage('ë ˆì´ì¦ˆ ë¶ˆê°€. ì¹© ë¶€ì¡±');
                return;
            }
            let raiseExtra = 20;
            let totalRaise = callAmount + raiseExtra;
            if (playerStack < totalRaise) totalRaise = playerStack;
            playerStack -= totalRaise;
            playerContribution += totalRaise;
            pot += totalRaise;
            currentBet = playerContribution;
            setMessage(`ë ˆì´ì¦ˆ ì´ ${totalRaise}ì¹©`);
            updateAllDisplays();
            opponentAction('raise', totalRaise - callAmount);
        }

        function checkRoundEndOrOpponentAction(playerMove) {
            if (playerContribution === opponentContribution) {
                endBettingRound();
            } else {
                opponentAction(playerMove);
            }
        }

        // ëª¬í…Œì¹´ë¥¼ë¡œ EV ì¶”ì • í•¨ìˆ˜ (ë³€ê²½ ì—†ìŒ)
        function monteCarloEV(playerC, oppC, commC, stage) {
            let used = playerC.concat(oppC, commC);
            let remainingDeck = deck.filter(c => !used.includes(c));
            let simulations = 200;
            let playerWins = 0, oppWins = 0, ties = 0;

            for (let i = 0; i < simulations; i++) {
                let simDeck = remainingDeck.slice();
                shuffleArray(simDeck);
                let simCommunity = commC.slice();
                if (stage === 'preflop') {
                    simCommunity = simCommunity.concat(simDeck.splice(0, 3));
                    simCommunity = simCommunity.concat(simDeck.splice(0, 1));
                    simCommunity = simCommunity.concat(simDeck.splice(0, 1));
                } else if (stage === 'flop') {
                    simCommunity = simCommunity.concat(simDeck.splice(0, 1));
                    simCommunity = simCommunity.concat(simDeck.splice(0, 1));
                } else if (stage === 'turn') {
                    simCommunity = simCommunity.concat(simDeck.splice(0, 1));
                }
                // riverë©´ ì´ë¯¸ ì™„ì„±

                let pr = evaluateHand(playerC.concat(simCommunity));
                let orr = evaluateHand(oppC.concat(simCommunity));
                if (pr.rank > orr.rank || (pr.rank === orr.rank && pr.high > orr.high)) {
                    playerWins++;
                } else if (pr.rank < orr.rank || (pr.rank === orr.rank && pr.high < orr.high)) {
                    oppWins++;
                } else {
                    ties++;
                }
            }
            let playerEV = (playerWins + ties * 0.5) / simulations;
            return playerEV;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function opponentAction(playerMove, amount = 0) {
            if (gameOver) return;
            setTimeout(() => {
                let stage = gameStage;
                let oppEV = monteCarloEV(opponentCards, playerCards, communityCards, stage);
                let callAmount = currentBet - opponentContribution;
                let action = '';

                if (playerMove === 'check') {
                    if (callAmount > 0) {
                        // ì´ë¡ ìƒ ì—†ìŒ
                    } else {
                        if (oppEV > 0.6) action = 'bet';
                        else if (oppEV > 0.4) action = 'check';
                        else action = 'check';
                    }
                } else if (playerMove === 'bet' || playerMove === 'raise') {
                    if (oppEV < 0.3) action = 'fold';
                    else if (oppEV > 0.5) action = 'call';
                    else action = 'call';
                } else if (playerMove === 'call') {
                    if (oppEV > 0.5) action = 'bet';
                    else action = 'check';
                }

                if (action === 'fold') {
                    setMessage('ìƒëŒ€ í´ë“œ! í”Œë ˆì´ì–´ ìŠ¹ë¦¬!');
                    playerStack += pot;
                    endHand();
                } else if (action === 'check') {
                    setMessage('ìƒëŒ€ ì²´í¬');
                    opponentCheck();
                } else if (action === 'bet') {
                    opponentBet(20);
                } else if (action === 'call') {
                    opponentCall();
                }
            }, 1000);
        }

        function opponentCheck() {
            if (playerContribution === opponentContribution) {
                endBettingRound();
            } else {
                endBettingRound();
            }
        }

        function opponentBet(betSize) {
            if (opponentStack < betSize) betSize = opponentStack;
            opponentStack -= betSize;
            opponentContribution += betSize;
            pot += betSize;
            currentBet = opponentContribution;
            setMessage(`ìƒëŒ€ ë² íŒ… ${betSize}ì¹©`);
            updateAllDisplays();
        }

        function opponentCall() {
            let callAmount = currentBet - opponentContribution;
            if (opponentStack < callAmount) callAmount = opponentStack;
            opponentStack -= callAmount;
            opponentContribution += callAmount;
            pot += callAmount;
            setMessage(`ìƒëŒ€ ì½œ ${callAmount}ì¹©`);
            updateAllDisplays();
            endBettingRound();
        }

        function endBettingRound() {
            if (gameOver) return;
            currentBet = 0;
            playerContribution = 0;
            opponentContribution = 0;

            if (gameStage === 'preflop') {
                communityCards = [deck.pop(), deck.pop(), deck.pop()];
                gameStage = 'flop';
                setMessage('í”Œë ê³µê°œ');
            } else if (gameStage === 'flop') {
                communityCards.push(deck.pop());
                gameStage = 'turn';
                setMessage('í„´ ì¹´ë“œ ê³µê°œ');
            } else if (gameStage === 'turn') {
                communityCards.push(deck.pop());
                gameStage = 'river';
                setMessage('ë¦¬ë²„ ì¹´ë“œ ê³µê°œ');
            } else if (gameStage === 'river') {
                showDown();
                return;
            }

            // ìŠ¤í…Œì´ì§€ ì¸ë””ì¼€ì´í„° ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            updateStageIndicator();
            updateAllDisplays();
        }

        function showDown() {
            gameStage = 'showdown';
            updateAllDisplays();
            updateOpponentCardsDisplay(true);

            const playerHand = playerCards.concat(communityCards);
            const opponentHand = opponentCards.concat(communityCards);
            const playerRank = evaluateHand(playerHand);
            const oppRank = evaluateHand(opponentHand);
            const winner = determineWinner();

            if (winner === 'player') {
                setMessage(`ì‡¼ë‹¤ìš´! í”Œë ˆì´ì–´ ìŠ¹! (ë‚´ íŒ¨:${getRankName(playerRank.rank)}, ìƒëŒ€:${getRankName(oppRank.rank)}) ì¶•í•˜í•©ë‹ˆë‹¤!`);
                playerStack += pot;
            } else if (winner === 'opponent') {
                setMessage(`ì‡¼ë‹¤ìš´! ìƒëŒ€ ìŠ¹! (ë‚´ íŒ¨:${getRankName(playerRank.rank)}, ìƒëŒ€:${getRankName(oppRank.rank)}) ì•„ì‰½ìŠµë‹ˆë‹¤.`);
                opponentStack += pot;
            } else {
                setMessage(`ì‡¼ë‹¤ìš´! ë¬´ìŠ¹ë¶€! (ë‚´ íŒ¨:${getRankName(playerRank.rank)}, ìƒëŒ€:${getRankName(oppRank.rank)}) íŒŸ ë‚˜ëˆ”!`);
                playerStack += pot / 2;
                opponentStack += pot / 2;
            }
            endHand();
        }

        function getRankName(rank) {
            switch (rank) {
                case 9: return 'ë¡œì—´ ìŠ¤íŠ¸ë ˆì´íŠ¸ í”ŒëŸ¬ì‰¬';
                case 8: return 'ìŠ¤íŠ¸ë ˆì´íŠ¸ í”ŒëŸ¬ì‰¬';
                case 7: return 'í¬ì¹´ë“œ';
                case 6: return 'í’€í•˜ìš°ìŠ¤';
                case 5: return 'í”ŒëŸ¬ì‰¬';
                case 4: return 'ìŠ¤íŠ¸ë ˆì´íŠ¸';
                case 3: return 'íŠ¸ë¦¬í”Œ';
                case 2: return 'íˆ¬í˜ì–´';
                case 1: return 'ì›í˜ì–´';
                case 0: return 'í•˜ì´ì¹´ë“œ';
                default: return '';
            }
        }

        function endHand() {
            gameOver = true;
            updateAllDisplays();
            disableAllButtons();
            saveToStorage();
            document.getElementById('next-game-button').style.display = 'inline';
        }

        // ì¡±ë³´ í‰ê°€ ë¡œì§
        function evaluateHand(cards) {
            return evaluate7Cards(cards);
        }

        function evaluate7Cards(cards) {
            const all5Combos = get5CardCombos(cards);
            let best = { rank: -1, highCard: -1 };
            for (let combo of all5Combos) {
                let res = evaluate5Cards(combo);
                if (res.rank > best.rank || (res.rank === best.rank && res.highCard > best.highCard)) {
                    best = res;
                }
            }
            return best;
        }

        function get5CardCombos(cards) {
            const results = [];
            const n = cards.length;
            for (let a = 0; a < n - 4; a++) {
                for (let b = a + 1; b < n - 3; b++) {
                    for (let c = b + 1; c < n - 2; c++) {
                        for (let d = c + 1; d < n - 1; d++) {
                            for (let e = d + 1; e < n; e++) {
                                results.push([cards[a], cards[b], cards[c], cards[d], cards[e]]);
                            }
                        }
                    }
                }
            }
            return results;
        }

        function evaluate5Cards(cards) {
            const sortedCards = cards.slice().sort((a, b) => {
                const va = values.indexOf(a[0]);
                const vb = values.indexOf(b[0]);
                return va - vb;
            });
            const cardValues = sortedCards.map(c => values.indexOf(c[0]));
            const cardSuits = sortedCards.map(c => c[1]);
            const isFlush = cardSuits.every((s, i, arr) => s === arr[0]);
            const isStraight = cardValues.every((val, i) => i === 0 || val === cardValues[i - 1] + 1);
            const isRoyal = isStraight && cardValues[0] === 8;
            const valueCounts = {};
            cardValues.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
            const counts = Object.values(valueCounts);
            const maxCount = Math.max(...counts);

            let rank = 0, high = 0;
            if (isRoyal && isFlush) { rank = 9; high = 14; }
            else if (isStraight && isFlush) { rank = 8; high = cardValues[4]; }
            else if (maxCount === 4) { rank = 7; high = getKeyByValueCount(valueCounts, 4); }
            else if (counts.includes(3) && counts.includes(2)) { rank = 6; high = getKeyByValueCount(valueCounts, 3); }
            else if (isFlush) { rank = 5; high = cardValues[4]; }
            else if (isStraight) { rank = 4; high = cardValues[4]; }
            else if (maxCount === 3) { rank = 3; high = getKeyByValueCount(valueCounts, 3); }
            else if (counts.filter(c => c === 2).length === 2) {
                rank = 2;
                let pairs = getKeysByCount(valueCounts, 2);
                high = Math.max(...pairs);
            }
            else if (maxCount === 2) {
                rank = 1; high = getKeyByValueCount(valueCounts, 2);
            } else {
                rank = 0; high = cardValues[4];
            }
            return { rank, high };
        }

        function getKeyByValueCount(valueCounts, count) {
            for (let v in valueCounts) {
                if (valueCounts[v] === count) return parseInt(v);
            }
            return -1;
        }

        function getKeysByCount(valueCounts, count) {
            let keys = [];
            for (let v in valueCounts) {
                if (valueCounts[v] === count) keys.push(parseInt(v));
            }
            return keys;
        }

        function determineWinner() {
            const playerHand = playerCards.concat(communityCards);
            const opponentHand = opponentCards.concat(communityCards);
            const pr = evaluateHand(playerHand);
            const orr = evaluateHand(opponentHand);
            if (pr.rank > orr.rank) return 'player';
            else if (pr.rank < orr.rank) return 'opponent';
            else {
                if (pr.high > orr.high) return 'player';
                else if (pr.high < orr.high) return 'opponent';
                else return 'tie';
            }
        }

        document.addEventListener('DOMContentLoaded', startGame);
    </script>
</body>

</html>
