<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>텍사스 홀덤 싱글 플레이 연습</title>
    <link rel="stylesheet" href="holdem3.css">
</head>

<body>
    <div class="container">
        <h1>텍사스 홀덤 싱글 플레이 연습</h1>
        <button onclick="resetChips()">칩 리셋</button>
        <div class="game-area">
            <div class="stage-indicator" id="stage-indicator">
                프리플랍
                <div class="stage-tooltip" id="stage-tooltip">
                    <strong>현재 라운드: 프리플랍</strong><br>
                    홀카드 2장 배분 후 첫 베팅 단계.<br>
                    모두 콜하거나 체크하면 다음 단계로 진행합니다.
                </div>
            </div>
            <div class="genie-advice" id="genie">
                <h3>지니의 조언</h3>
                <div id="genie-message">게임 시작</div>
            </div>

            <div class="opponent-area">
                <div class="chips-info">
                    상대 칩: <span id="opponent-stack">1000</span>
                    <span class="tooltip">💰
                        <span class="tooltiptext">상대방 현재 칩 수량</span>
                    </span>
                </div>
                <h2>상대(딜러)</h2>
                <div class="opponent-cards" id="opponent-cards"></div>
            </div>
            <div class="community-cards" id="community-cards"></div>
            <div class="player-area">
                <div class="chips-info">
                    내 칩: <span id="player-stack">1000</span>
                    <span class="tooltip">💰
                        <span class="tooltiptext">내가 보유한 칩 수량<br>지속적으로 누적됩니다.</span>
                    </span>
                </div>
                <h2>플레이어 (<span id="blind-info">?</span>)</h2>
                <div class="player-cards" id="player-cards"></div>
                <div class="action-buttons">
                    <button onclick="playerCheck()">체크
                        <div class="action-tooltip">추가 베팅 없이 넘깁니다.</div>
                    </button>
                    <button onclick="playerBet()">베팅
                        <div class="action-tooltip">베팅 시작</div>
                    </button>
                    <button onclick="playerCall()">콜
                        <div class="action-tooltip">상대 베팅에 맞추기</div>
                    </button>
                    <button onclick="playerRaise()">레이즈
                        <div class="action-tooltip">상대보다 높게 베팅</div>
                    </button>
                    <button onclick="playerFold()">폴드
                        <div class="action-tooltip">패 포기</div>
                    </button>
                </div>
                <div class="pot" id="pot-amount">팟: 0</div>
                <div class="message-area" id="message-area"></div>
                <button id="next-game-button" style="display:none;" onclick="nextGame()">다음 게임</button>
            </div>
        </div>

        <div class="rules-area fade-in">
            <h2>게임 진행 & 베팅 라운드</h2>
            <p><strong>헤즈업 텍사스 홀덤</strong>: 2인 플레이. SB:5, BB:10</p>
            <p>첫 게임 시작 시 SB/BB는 랜덤으로 결정되고, 이후 게임마다 SB/BB가 번갈아가며 돌아갑니다.</p>
            <p>진행 순서:</p>
            <ul>
                <li><strong>프리플랍</strong>: 홀카드 2장 후 베팅</li>
                <li><strong>플랍</strong>: 커뮤니티 카드 3장 공개 후 베팅</li>
                <li><strong>턴</strong>: 커뮤니티 카드 4장째 공개 후 베팅</li>
                <li><strong>리버</strong>: 커뮤니티 카드 5장째 공개 후 베팅</li>
                <li><strong>쇼다운</strong>: 모두 베팅 종료 후 패 비교</li>
            </ul>
            <p>각 단계에서 콜/체크로 베팅이 마무리되면 다음 단계 진행.</p>
            <h2>족보(높은순)</h2>
            <ul>
                <li>로열 스트레이트 플러쉬</li>
                <li>스트레이트 플러쉬</li>
                <li>포카드</li>
                <li>풀하우스</li>
                <li>플러쉬</li>
                <li>스트레이트</li>
                <li>트리플</li>
                <li>투페어</li>
                <li>원페어</li>
                <li>하이카드</li>
            </ul>
        </div>
    </div>
    <script>
        let deck = [];
        const suits = ["C", "D", "H", "S"];
        const values = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"];

        let playerStack;
        let opponentStack;
        let pot = 0;
        let playerCards = [];
        let opponentCards = [];
        let communityCards = [];
        let gameStage = 'preflop';
        let gameOver = false;

        let currentBet = 0;
        let playerContribution = 0;
        let opponentContribution = 0;

        let smallBlind = 5;
        let bigBlind = 10;
        let playerIsSB; // 플레이어가 SB인지 여부
        // SB/BB 스위칭: 첫 게임에 랜덤 결정, 이후 번갈아
        // 로컬스토리지에 playerStack, opponentStack, playerIsSB 저장

        function loadFromStorage() {
            let storedPStack = localStorage.getItem('playerStack');
            let storedOStack = localStorage.getItem('opponentStack');
            let storedSB = localStorage.getItem('playerIsSB');
            if (storedPStack && storedOStack && storedSB) {
                playerStack = parseInt(storedPStack);
                opponentStack = parseInt(storedOStack);
                playerIsSB = (storedSB === 'true');
            } else {
                // 초기값
                playerStack = 1000;
                opponentStack = 1000;
                playerIsSB = Math.random() < 0.5;
            }
        }

        function saveToStorage() {
            localStorage.setItem('playerStack', playerStack.toString());
            localStorage.setItem('opponentStack', opponentStack.toString());
            localStorage.setItem('playerIsSB', playerIsSB.toString());
        }

        function resetChips() {
            localStorage.removeItem('playerStack');
            localStorage.removeItem('opponentStack');
            localStorage.removeItem('playerIsSB');
            playerStack = 1000;
            opponentStack = 1000;
            playerIsSB = Math.random() < 0.5;
            startGame();
        }

        function createDeck() {
            deck = [];
            for (let s of suits) {
                for (let v of values) {
                    deck.push(v + s);
                }
            }
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function startGame() {
            loadFromStorage();
            gameOver = false;
            communityCards = [];
            currentBet = 0;
            playerContribution = 0;
            opponentContribution = 0;

            gameStage = 'preflop';
            // 블라인드 세팅
            let sbPlayer, bbPlayer;
            if (playerIsSB) {
                sbPlayer = "player";
                bbPlayer = "opponent";
            } else {
                sbPlayer = "opponent";
                bbPlayer = "player";
            }

            if (sbPlayer === "player") {
                playerStack -= smallBlind;
                opponentStack -= bigBlind;
            } else {
                opponentStack -= smallBlind;
                playerStack -= bigBlind;
            }
            pot = smallBlind + bigBlind;
            currentBet = bigBlind;

            createDeck();
            shuffleDeck();
            dealHoleCards();
            enableAllButtons();
            document.getElementById('next-game-button').style.display = 'none';
            updateAllDisplays();
            setMessage(`새 게임 시작! SB:${smallBlind}, BB:${bigBlind}`);
            updateGenieMessage();
            updateBlindInfo();
        }

        function nextGame() {
            // SB/BB 스위칭
            playerIsSB = !playerIsSB;
            saveToStorage();
            startGame();
        }

        function updateBlindInfo() {
            const bi = document.getElementById('blind-info');
            if (!bi) return;
            if (playerIsSB) bi.textContent = 'SB';
            else bi.textContent = 'BB';
        }

        function dealHoleCards() {
            playerCards = [deck.pop(), deck.pop()];
            opponentCards = [deck.pop(), deck.pop()];
        }

        function updateAllDisplays() {
            updateStageIndicator();
            updatePlayerCardsDisplay();
            updateOpponentCardsDisplay();
            updateCommunityCardsDisplay();
            updatePotDisplay();
            updateStacksDisplay();
            updateGenieMessage();
        }

        function updateStacksDisplay() {
            document.getElementById('player-stack').textContent = playerStack;
            document.getElementById('opponent-stack').textContent = opponentStack;
        }

        function cardToDisplay(card) {
            const rankMap = { 'T': '10', 'J': 'J', 'Q': 'Q', 'K': 'K', 'A': 'A' };
            let rank = card[0];
            if (rankMap[rank]) rank = rankMap[rank];
            let suit = card[1];
            let suitChar, colorClass;
            switch (suit) {
                case 'C': suitChar = '♣'; colorClass = 'black'; break;
                case 'D': suitChar = '♦'; colorClass = 'red'; break;
                case 'H': suitChar = '♥'; colorClass = 'red'; break;
                case 'S': suitChar = '♠'; colorClass = 'black'; break;
            }
            return { text: rank + suitChar, color: colorClass };
        }

        function updatePlayerCardsDisplay() {
            const pc = document.getElementById('player-cards');
            if (!pc) return;
            pc.innerHTML = '';
            playerCards.forEach(card => {
                const { text, color } = cardToDisplay(card);
                let cardDiv = document.createElement('div');
                cardDiv.classList.add('card', color);
                cardDiv.textContent = text;
                pc.appendChild(cardDiv);
            });
        }

        function updateOpponentCardsDisplay(showDown = false) {
            const oc = document.getElementById('opponent-cards');
            if (!oc) return;
            oc.innerHTML = '';
            if (gameOver || showDown || gameStage === 'showdown') {
                // flip animation for reveal
                opponentCards.forEach(card => {
                    const { text, color } = cardToDisplay(card);
                    const cardDiv = document.createElement('div');
                    cardDiv.classList.add('card', color);
                    cardDiv.textContent = text;
                    oc.appendChild(cardDiv);
                });
            } else {
                // facedown cards
                oc.innerHTML = `<div class="card back"></div><div class="card back"></div>`;
            }
        }

        function updateCommunityCardsDisplay() {
            const cc = document.getElementById('community-cards');
            if (!cc) return;
            cc.innerHTML = '';
            communityCards.forEach(card => {
                const { text, color } = cardToDisplay(card);
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card', color);
                cardDiv.textContent = text;
                cc.appendChild(cardDiv);
            });
            while (cc.childElementCount < 5) {
                const emptyCard = document.createElement('div');
                emptyCard.classList.add('card', 'back');
                emptyCard.textContent = '';
                cc.appendChild(emptyCard);
            }
        }

        function updatePotDisplay() {
            const potElem = document.getElementById('pot-amount');
            if (!potElem) return;
            potElem.textContent = `팟: ${pot}`;
        }

        function updateStageIndicator() {
            const si = document.getElementById('stage-indicator');
            const stt = document.getElementById('stage-tooltip');
            if (!si || !stt) return;
            let desc = '';
            switch (gameStage) {
                case 'preflop':
                    si.textContent = '프리플랍';
                    desc = '홀카드 2장 후 베팅 단계.';
                    break;
                case 'flop':
                    si.textContent = '플랍';
                    desc = '커뮤니티 카드 3장 공개 후 베팅.';
                    break;
                case 'turn':
                    si.textContent = '턴';
                    desc = '4번째 커뮤니티 카드 공개 후 베팅.';
                    break;
                case 'river':
                    si.textContent = '리버';
                    desc = '5번째 커뮤니티 카드 공개 후 베팅.';
                    break;
                case 'showdown':
                    si.textContent = '쇼다운';
                    desc = '베팅 종료 후 패 공개, 승자 결정.';
                    break;
                default:
                    si.textContent = '';
            }
            stt.innerHTML = '<strong>현재 라운드: ' + si.textContent + '</strong><br>' + desc;
        }

        function setMessage(msg) {
            const msgArea = document.getElementById('message-area');
            if (!msgArea) return;
            msgArea.textContent = msg;
        }

        function updateGenieMessage() {
            const genie = document.getElementById('genie-message');
            if (!genie) return;
            if (gameOver) {
                genie.textContent = '쇼다운 완료! [다음 게임] 버튼을 눌러주세요.';
                return;
            }
            let callAmount = currentBet - playerContribution;
            if (callAmount > 0) {
                genie.textContent = `상대 베팅 ${callAmount}칩. 콜/레이즈/폴드 선택 가능.`;
            } else {
                genie.textContent = `추가 베팅 없음. 체크나 베팅/레이즈 가능!`;
            }
        }

        function disableAllButtons() {
            const buttons = document.querySelectorAll('.action-buttons button');
            buttons.forEach(b => b.disabled = true);
        }
        function enableAllButtons() {
            const buttons = document.querySelectorAll('.action-buttons button');
            buttons.forEach(b => b.disabled = false);
        }

        function playerFold() {
            if (gameOver) return;
            setMessage('폴드! 상대 승리');
            opponentStack += pot;
            endHand();
        }

        function playerCheck() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (callAmount > 0) {
                setMessage('체크 불가! 콜 또는 폴드해야 합니다.');
                return;
            }
            setMessage('체크');
            updateAllDisplays();
            opponentAction('check');
        }

        function playerBet() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (callAmount > 0) {
                setMessage('콜/폴드/레이즈 해야합니다. 베팅 불가.');
                return;
            }
            let betSize = 20;
            if (playerStack < betSize) betSize = playerStack;
            playerStack -= betSize;
            playerContribution += betSize;
            pot += betSize;
            currentBet = playerContribution;
            setMessage(`베팅 ${betSize}칩`);
            updateAllDisplays();
            opponentAction('bet', betSize);
        }

        function playerCall() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (callAmount <= 0) {
                setMessage('콜할 베팅이 없습니다.');
                return;
            }
            if (playerStack < callAmount) callAmount = playerStack;
            playerStack -= callAmount;
            playerContribution += callAmount;
            pot += callAmount;
            setMessage(`콜 ${callAmount}칩`);
            updateAllDisplays();
            checkRoundEndOrOpponentAction('call');
        }

        function playerRaise() {
            if (gameOver) return;
            let callAmount = currentBet - playerContribution;
            if (playerStack <= callAmount) {
                setMessage('레이즈 불가. 칩 부족');
                return;
            }
            let raiseExtra = 20;
            let totalRaise = callAmount + raiseExtra;
            if (playerStack < totalRaise) totalRaise = playerStack;
            playerStack -= totalRaise;
            playerContribution += totalRaise;
            pot += totalRaise;
            currentBet = playerContribution;
            setMessage(`레이즈 총 ${totalRaise}칩`);
            updateAllDisplays();
            opponentAction('raise', totalRaise - callAmount);
        }

        function checkRoundEndOrOpponentAction(playerMove) {
            if (playerContribution === opponentContribution) {
                endBettingRound();
            } else {
                opponentAction(playerMove);
            }
        }

        function opponentAction(playerMove, amount = 0) {
            if (gameOver) return;
            setTimeout(() => {
                let actionRand = Math.random();

                if (playerMove === 'check') {
                    if (actionRand < 0.5) {
                        setMessage('상대 체크');
                        opponentCheck();
                    } else {
                        opponentBet(20);
                    }
                } else if (playerMove === 'bet' || playerMove === 'raise') {
                    // 상대 콜/폴드
                    if (actionRand < 0.5) {
                        opponentCall();
                    } else {
                        setMessage('상대 폴드! 플레이어 승리');
                        playerStack += pot;
                        endHand();
                    }
                } else if (playerMove === 'call') {
                    if (actionRand < 0.5) {
                        setMessage('상대 체크');
                        opponentCheck();
                    } else {
                        opponentBet(20);
                    }
                }
            }, 1000);
        }

        function opponentCheck() {
            if (playerContribution === opponentContribution) {
                endBettingRound();
            } else {
                endBettingRound();
            }
        }

        function opponentBet(betSize) {
            if (opponentStack < betSize) betSize = opponentStack;
            opponentStack -= betSize;
            opponentContribution += betSize;
            pot += betSize;
            currentBet = opponentContribution;
            setMessage(`상대 베팅 ${betSize}칩`);
            updateAllDisplays();
        }

        function opponentCall() {
            let callAmount = currentBet - opponentContribution;
            if (opponentStack < callAmount) callAmount = opponentStack;
            opponentStack -= callAmount;
            opponentContribution += callAmount;
            pot += callAmount;
            setMessage(`상대 콜 ${callAmount}칩`);
            updateAllDisplays();
            endBettingRound();
        }

        function endBettingRound() {
            if (gameOver) return;
            currentBet = 0;
            playerContribution = 0;
            opponentContribution = 0;

            if (gameStage === 'preflop') {
                communityCards = [deck.pop(), deck.pop(), deck.pop()];
                gameStage = 'flop';
                setMessage('플랍 공개');
            } else if (gameStage === 'flop') {
                communityCards.push(deck.pop());
                gameStage = 'turn';
                setMessage('턴 카드 공개');
            } else if (gameStage === 'turn') {
                communityCards.push(deck.pop());
                gameStage = 'river';
                setMessage('리버 카드 공개');
            } else if (gameStage === 'river') {
                showDown();
                return;
            }
            updateAllDisplays();
        }

        function showDown() {
            gameStage = 'showdown';
            const winner = determineWinner();
            updateAllDisplays();
            updateOpponentCardsDisplay(true);
            highlightBestRank();
            if (winner === 'player') {
                setMessage('쇼다운! 플레이어 승!');
                playerStack += pot;
            } else if (winner === 'opponent') {
                setMessage('쇼다운! 상대 승!');
                opponentStack += pot;
            } else {
                setMessage('쇼다운! 무승부! 팟 나누기');
                playerStack += pot / 2;
                opponentStack += pot / 2;
            }
            endHand();
        }

        function highlightBestRank() {
            const playerHand = playerCards.concat(communityCards);
            const rankInfo = evaluateHand(playerHand);
            const pc = document.getElementById('player-cards');
            if (!pc) return;
            // playerHand rank에 따라 highlight
            // rank 9: 로열, 8: 스트플, 7:포카드 ...
            // 그냥 rank 값 있으면 highlight
            pc.classList.add('highlight-rank');
            setMessage(`${getRankName(rankInfo.rank)} (플레이어 패 랭크)`);
        }

        function getRankName(rank) {
            switch (rank) {
                case 9: return '로열 스트레이트 플러쉬';
                case 8: return '스트레이트 플러쉬';
                case 7: return '포카드';
                case 6: return '풀하우스';
                case 5: return '플러쉬';
                case 4: return '스트레이트';
                case 3: return '트리플';
                case 2: return '투페어';
                case 1: return '원페어';
                case 0: return '하이카드';
                default: return '';
            }
        }

        function endHand() {
            gameOver = true;
            updateAllDisplays();
            disableAllButtons();
            saveToStorage();
            document.getElementById('next-game-button').style.display = 'inline';
        }

        function evaluateHand(cards) {
            const sortedCards = cards.slice().sort((a, b) => {
                const va = values.indexOf(a[0]);
                const vb = values.indexOf(b[0]);
                return va - vb;
            });
            const cardValues = sortedCards.map(c => values.indexOf(c[0]));
            const cardSuits = sortedCards.map(c => c[1]);
            const isFlush = cardSuits.every((s, i, arr) => s === arr[0]);
            const isStraight = cardValues.every((val, i) => i === 0 || val === cardValues[i - 1] + 1);
            const isRoyal = isStraight && cardValues[0] === 8;
            const valueCounts = {};
            cardValues.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
            const counts = Object.values(valueCounts);
            const maxCount = Math.max(...counts);

            let rank = 0, high = 0;
            if (isRoyal && isFlush) { rank = 9; high = 14; }
            else if (isStraight && isFlush) { rank = 8; high = cardValues[4]; }
            else if (maxCount === 4) { rank = 7; high = cardValues.find(v => valueCounts[v] === 4); }
            else if (counts.includes(3) && counts.includes(2)) { rank = 6; high = cardValues.find(v => valueCounts[v] === 3); }
            else if (isFlush) { rank = 5; high = cardValues[4]; }
            else if (isStraight) { rank = 4; high = cardValues[4]; }
            else if (maxCount === 3) { rank = 3; high = cardValues.find(v => valueCounts[v] === 3); }
            else if (counts.filter(c => c === 2).length === 2) {
                rank = 2;
                let pairs = cardValues.filter(v => valueCounts[v] === 2);
                high = Math.max(...pairs);
            }
            else if (maxCount === 2) {
                rank = 1; high = cardValues.find(v => valueCounts[v] === 2);
            } else {
                rank = 0; high = cardValues[4];
            }
            return { rank, high };
        }

        function determineWinner() {
            const playerHand = playerCards.concat(communityCards);
            const opponentHand = opponentCards.concat(communityCards);
            const pr = evaluateHand(playerHand);
            const orr = evaluateHand(opponentHand);
            if (pr.rank > orr.rank) return 'player';
            else if (pr.rank < orr.rank) return 'opponent';
            else {
                if (pr.high > orr.high) return 'player';
                else if (pr.high < orr.high) return 'opponent';
                else return 'tie';
            }
        }

        document.addEventListener('DOMContentLoaded', startGame);
    </script>
</body>

</html>
